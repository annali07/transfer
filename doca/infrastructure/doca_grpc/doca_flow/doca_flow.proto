/*
 * Copyright (c) 2021-2022 NVIDIA CORPORATION & AFFILIATES, ALL RIGHTS RESERVED.
 *
 * This software product is a proprietary product of NVIDIA CORPORATION &
 * AFFILIATES (the "Company") and all right, title, and interest in and to the
 * software product, including all associated intellectual property rights, are
 * and shall remain exclusively with the Company.
 *
 * This software product is governed by the End User License Agreement
 * provided with the software product.
 *
 */

syntax = "proto3";

/*
 * DOCA Flow service definition
 */
service DocaFlow {

	/* DOCA Flow initialization */
	rpc DocaFlowInit (DocaFlowCfg) returns (DocaFlowResponse);

	/* DOCA Flow destroy */
	rpc DocaFlowDestroy (DocaFlowEmptyRequest) returns (DocaFlowResponse);

	/* DOCA Flow port start */
	rpc DocaFlowPortStart (DocaFlowPortCfg) returns (DocaFlowResponse);

	/* DOCA Flow port stop */
	rpc DocaFlowPortStop (DocaFlowPort) returns (DocaFlowResponse);

	/* DOCA Flow pair two ports */
	rpc DocaFlowPortPair(DocaFlowPortPairRequest) returns (DocaFlowResponse);

	/* DOCA Flow port private data */
	rpc DocaFlowPortPrivData (DocaFlowPort) returns (DocaFlowResponse);

	/* DOCA Flow configures a single shared resource */
	rpc DocaFlowSharedResourceCfg (DocaFlowSharedResourceCfgRequest) returns (DocaFlowResponse);

	/* DOCA Flow Binds a bulk of shared resources to a bindable object */
	rpc DocaFlowSharedResourcesBind (DocaFlowSharedResourcesBindRequest) returns (DocaFlowResponse);

	/* DOCA Flow query an array of shared objects of a specific type */
	rpc DocaFlowSharedResourcesQuery (DocaFlowSharedResourcesQueryRequest) returns (DocaFlowResponse);

	/* DOCA Flow create pipe */
	rpc DocaFlowPipeCreate (DocaFlowPipeCreateRequest) returns (DocaFlowResponse);

	/* DOCA Flow adding entry to a pipe */
	rpc DocaFlowPipeAddEntry (DocaFlowPipeAddEntryRequest) returns (DocaFlowResponse);

	/* DOCA Flow update pipe entry */
	rpc DocaFlowPipeUpdateEntry (DocaFlowPipeUpdateEntryRequest) returns (DocaFlowResponse);

	/* DOCA Flow adding control entry to a pipe */
	rpc DocaFlowPipeControlAddEntry (DocaFlowPipeControlAddEntryRequest) returns (DocaFlowResponse);

	/* DOCA Flow adding LPM entry to a pipe */
	rpc DocaFlowPipeLpmAddEntry (DocaFlowPipeLpmAddEntryRequest) returns (DocaFlowResponse);

	/* DOCA Flow update entry */
	rpc DocaFlowPipeLpmUpdateEntry (DocaFlowPipeUpdateEntryRequest) returns (DocaFlowResponse);

	/* DOCA Flow remove entry */
	rpc DocaFlowPipeRmEntry (DocaFlowPipeRmEntryRequest) returns (DocaFlowResponse);

	/* DOCA Flow pipe destroy request */
	rpc DocaFlowPipeDestroy (DocaFlowPipeDestroyRequest) returns (DocaFlowResponse);

	/* DOCA Flow flush pipe */
	rpc DocaFlowPortPipesFlush (DocaFlowPort) returns (DocaFlowResponse);

	/* DOCA Flow dump pipe */
	rpc DocaFlowPipeDump (DocaFlowPipe) returns (DocaFlowResponse);

	/* DOCA Flow dump pipes */
	rpc DocaFlowPortPipesDump (DocaFlowPort) returns (DocaFlowResponse);

	/* DOCA Flow extracting information about a specific entry */
	rpc DocaFlowQueryEntry (DocaFlowQueryEntryRequest) returns (DocaFlowResponse);

	/* DOCA Flow extracting information about pipe miss entry */
	rpc DocaFlowQueryPipeMiss (DocaFlowPipe) returns (DocaFlowResponse);

	/* DOCA Flow handle aging request */
	rpc DocaFlowAgingHandle (DocaFlowAgingHandleRequest) returns (DocaFlowResponse);

	/* DOCA Flow process entries in queue */
	rpc DocaFlowEntriesProcess(DocaFlowEntriesProcessRequest) returns (DocaFlowResponse);

	/* DOCA Flow get entry's status */
	rpc DocaFlowPipeEntryGetStatus(DocaFlowPipeEntryGetStatusRequest) returns (DocaFlowResponse);

	/* Doca Flow encode an MPLS label header */
	rpc DocaFlowMplsLabelEncode(DocaFlowMplsLabelEncodeRequest) returns (DocaFlowResponse);

	/* Doca Flow decode an MPLS label header */
	rpc DocaFlowMplsLabelDecode(DocaFlowMplsLabelDecodeRequest) returns (DocaFlowResponse);

	/* DOCA Flow  get switch port */
	rpc DocaFlowPortSwitchGet(DocaFlowEmptyRequest) returns (DocaFlowResponse);

	/* DOCA Flow add entry to the ordered list pipe request */
	rpc DocaFlowPipeOrderedListAddEntry(DocaFlowPipeOrderedListAddEntryRequest) returns (DocaFlowResponse);

	/* Doca Flow add entry to hash pipe request */
	rpc DocaFlowPipeHashAddEntry(DocaFlowPipeHashAddEntryRequest) returns (DocaFlowResponse);

	/* Doca Flow get target */
	rpc DocaFlowGetTarget(DocaFlowGetTargetRequest) returns (DocaFlowResponse);

	/* Shutting down DOCA Flow gRPC server - necessary for graceful termination */
	rpc ShutdownServer(DocaFlowEmptyRequest) returns (DocaFlowResponse);
}

/* ################################################## */
		/* Doca Flow Net Header messages */
/* ################################################## */

/* Doca flow vlan header */
message DocaFlowHeaderEthVlan {
	uint32 tci = 1;
}

/* Doca Flow eth header message */
message DocaFlowHeaderEth {
	uint64 src_mac = 1;	/* source mac address */
	uint64 dst_mac = 2;	/* destination mac address */
	uint32 type = 3;	/* Ethernet layer type */
}

/* DOCA Flow ip address message */
message DocaFlowIPAddr {
	uint32 type = 1;        		/* ip address type */
	uint32 ipv4_addr = 2;           /* IPv4 address if type is IPv4 */
	repeated uint32 ipv6_addr = 3;  /* IPv6 address if type is ipv6 (repeated length is 4) */
}

/* layer 4 packet extend type */
enum DocaFlowL4TypeExt {
	L4_TYPE_EXT_NONE = 0;		/* l4 ext type is not set */
	L4_TYPE_EXT_TCP = 1;		/* l4 ext type is tcp */
	L4_TYPE_EXT_UDP = 2;		/* l4 ext type is udp */
	L4_TYPE_EXT_ICMP = 3;		/* l4 ext type is icmp */
	L4_TYPE_EXT_ICMP6 = 4;		/* l4 ext type is icmp6 */
}

/* Doca Flow tcp or udp port header in match data */
message DocaFlowHeaderL4Port {
	uint32 src_port = 1;	/* source port */
	uint32 dst_port = 2;	/* destination port */
}

/* Doca flow udp header in match data */
message DocaFlowHeaderUdp {
	DocaFlowHeaderL4Port l4_port = 1;	/**< udp source and destination port */
}

/* Doca flow tcp header in match data */
message DocaFlowHeaderTcp {
	DocaFlowHeaderL4Port l4_port = 1;	/* tcp source and destination port */
	uint32 flags = 2;							/* tcp flags */
}

/* Doca flow icmp header in match data */
message DocaFlowHeaderIcmp {
	uint32 type = 1;	/* icmp type */
	uint32 code = 2;	/* icmp code */
	uint32 ident = 3;	/* icmp identifier */
}

/* DOCA flow ipv4 header in match data */
message DocaFlowHeaderIP4 {
	uint32 src_ip = 1;		/* IPv4 src address */
	uint32 dst_ip = 2;		/* IPv4 dst address */
	uint32 version_ihl = 3;		/* ip4 version and header length */
	uint32 dscp_ecn = 4;		/* dscp and ecn */
	uint32 next_proto = 5;		/* ip4 next protocol */
	uint32 ttl = 6;			/* ip4 time to live */
}

/* DOCA flow ipv6 header in match data */
message DocaFlowHeaderIP6 {
	repeated uint32 src_ip = 1;	/* IPv6 src address (repeated length is 4) */
	repeated uint32 dst_ip = 2;	/* IPv6 dst address (repeated length is 4) */
	uint32 dscp_ecn = 3;		/* dscp and ecn */
	uint32 next_proto = 4;		/* ip6 next protocol */
	uint32 hop_limit = 5;		/* ip6 hop limitation */
}

/* Doca Flow MPLS header. */
message DocaFlowHeaderMpls {
	uint32 label = 1;
}

/**
 * DOCA Flow GENEVE header.
 */
message DocaFlowHeaderGeneve {
	uint32 ver_opt_len = 1;		/* version (2) + options length (6) */
	uint32 o_c = 2;			/* OAM packet (1) + critical options present (1) +Â reserved (6) */
	uint32 next_proto = 3;		/* next protocol */
	uint32 vni = 4;			/* geneve vni (24) + reserved (8) */
}

/* DOCA Flow tunnel type */
enum DocaFlowTunType {
	TUN_NONE = 0;  		/* tunnel is not set */
	TUN_VXLAN = 1; 		/* tunnel is of type vxlan */
	TUN_GTPU = 2;  		/* tunnel is of type gtpu */
	TUN_GRE = 3;		/* tunnel is of type gre */
	TUN_ESP = 4;		/* tunnel is ipsec esp type */
	TUN_MPLS_O_UDP = 5;	/* tunnel os mpls over udp type */
	TUN_GENEVE = 6;		/* tunnel is geneve type */
}

message DocaVxlanTun {
	uint32 vxlan_tun_id = 1;  /* vxlan vni(24) + reserved (8) */
}

message DocaGreTun{
	uint32 gre_key = 1;     /* gre information (gre key) for gre tunnels */
	uint32 protocol = 2;	/* next protocol */
	bool key_present = 3;	/* gre key is present */
}

message DocaGtpTun {
	uint32 gtp_teid = 1;  /*  gtp teid */
}

/* ipsec esp header information if tunnel is esp */
message DocaIPsecEspHdr {
	uint32 esp_spi = 1; 		/* ipsec session parameter index */
	uint32 esp_sn = 2;		/* ipsec sequence number */
}

/* mpls information if tunnel is mpls over udp */
message DocaMplsHdr {
	repeated DocaFlowHeaderMpls mpls = 1;	/* mpls labels */
}

/* GENEVE header wrapper, if tunneling type is GENEVE */
message DocaGeneveHdr {
	DocaFlowHeaderGeneve geneve = 1;
}

/* DOCA Flow tunnel information message */
message DocaFlowTun {
	DocaFlowTunType type = 1; /* tunnel type */
	oneof tun_oneof {
		DocaVxlanTun vxlan = 2;
		DocaGreTun gre = 3;
		DocaGtpTun gtp = 4;
		DocaIPsecEspHdr ipsec_esp = 5;
		DocaMplsHdr mpls = 6;
		DocaGeneveHdr geneve = 7;
	}
}

/* ################################################## */
		/* Doca Flow Header messages */
/* ################################################## */

/* DOCA Flow port */
message DocaFlowPort {
	uint64 port_id = 1;
}

/* DOCA Flow pipe */
message DocaFlowPipe {
	uint64 pipe_id = 1;
}

/* Shared resource supported types */
enum DocaFlowSharedResourceType {
	SHARED_RESOURCE_METER = 0;	/* Shared meter type */
	SHARED_RESOURCE_COUNT = 1;	/* Shared counter type */
	SHARED_RESOURCE_RSS = 2;	/* Shared rss type */
	SHARED_RESOURCE_MIRROR = 4;	/* Shared mirror type */
	SHARED_RESOURCE_MAX = 5;	/* Shared max supported types */
}

/* Doca Flow flags type */
message DocaFlowResources {
	uint32 nb_counters = 1;		/* Number of counters to configure */
	uint32 nb_meters = 2;		/* Number of traffic meters to configure */
}

/* flags type for entry insertions */
enum FlagsType {
	NO_WAIT = 0;					/* entry will not be buffered */
	WAIT_FOR_BATCH = 2;				/* entry will be buffered */
}

/* Doca flow entry operation */
enum EntryOp {
	ENTRY_OP_ADD = 0; 	/* Add entry */
	ENTRY_OP_DEL = 1;	/* Delete entry */
}

/* Doca Flow entry status */
enum DocaFlowEntryStatus {
	ENTRY_STATUS_IN_PROCESS = 0;	/* The operation is in progress */
	ENTRY_STATUS_SUCCESS = 1;		/* The operation was completed successfully */
	ENTRY_STATUS_ERROR = 2;			/* The operation failed */
}

/* Doca Flow configuration flags */
enum DocaFlowCfgFlags {
	CFG_FLAGS_DEFAULT = 0;
	CFG_PIPE_MISS_MON = 2;	/* Counter pipe miss flow and query with doca_flow_query_pipe_miss() */
}

/* DOCA Flow configuration */
message DocaFlowCfg {
	uint64 flags = 1;				/* Configuraton flags */
	uint32 queues = 2;             			/* Queue id for each offload thread */
	DocaFlowResources resource = 3;
	string mode_args = 4;				/* set doca flow architecture mode switch, vnf */
	repeated uint32 nr_shared_resources = 5;	/* total shared resource per type */
	uint32 queue_depth = 6;				/* number of pre-configured queue_size, default to 128 */
}

/* DOCA Flow port type */
enum DocaFlowPortType {
	PORT_DPDK_BY_ID = 0;           /* DPDK port by mapping id */
}

/* DOCA Flow pipe type */
enum DocaFlowPipeType {
	PIPE_BASIC = 0;		/* Flow pipe */
	PIPE_CONTROL = 1;	/* Control pipe */
	PIPE_LPM = 2;		/* longest prefix match (LPM) pipe */
	PIPE_CT = 3;		/* Connection Tracking pipe */
	PIPE_ACL = 4;		/* ACL pipe */
	PIPE_ORDERED_LIST = 5;	/* Ordered list pipe */
	PIPE_HASH = 6;		/* Hash Pipe */
}

/**
 * @brief doca flow pipe domain
 */
 enum DocaFlowPipeDomain {
	PIPE_DOMAIN_DEFAULT = 0;	/* Default pipe domain for actions on ingress traffic */
	PIPE_DOMAIN_SECURE_INGRESS = 1;	/* Pipe domain for secure actions on ingress traffic */
	PIPE_DOMAIN_EGRESS = 2;		/* Pipe domain for actions on egress traffic */
	PIPE_DOMAIN_SECURE_EGRESS = 3;	/* Pipe domain for actions on egress traffic */
};

/* DOCA Flow port configuration for DOCA Flow port start */
message DocaFlowPortCfg {
	uint64 port_id = 1;            /* DPDK port id */
	DocaFlowPortType type = 2;     /* Port mapping type */
	string devargs = 3;            /* specific per port type cfg */
	uint32 priv_data_size = 4;     /* user private data size */
}

message CTMeta {
	uint32 type = 1; 		/* 0: traffic 1: SYN 2: RST 3: FIN. */
	uint32 hairpin = 2; 		/* Subject to forward using hairpin. */
	uint32 src = 3; 		/* Source port in multi-port E-Switch mode */
	uint32 zone = 4; 		/* Zone ID for CT processing. */
}

/* DOCA flow meta type */
message DocaFlowMeta {
	uint32 pkt_meta = 1;		/* Shared with application via packet */
	CTMeta ct = 2;			/* Metadata for CT */
	repeated uint32 u32 = 3;	/* Programmable user data. Should be of size USER_META_MAX_SIZE */
	uint32 port_meta = 4;		/* Programmable source vport */
	uint32 mark = 5;		/* Mark id of each queue */
	DocaFlowMeterColor meter_color = 6; /* Meter colors: Red, Yellow, Green */
}

/* DOCA flow match flags */
enum DocaFlowMatchTcpFlags {
	MATCH_TCP_NON = 0;		/* ignoring tcp flags */
	MATCH_TCP_FLAG_FIN = 1;		/* match tcp packet with Fin flag */
	MATCH_TCP_FLAG_SYN = 2;		/* match tcp packet with Syn flag */
	MATCH_TCP_FLAG_RST = 4;		/* match tcp packet with Rst flag */
	MATCH_TCP_FLAG_PSH = 8;		/* match tcp packet with Psh flag */
	MATCH_TCP_FLAG_ACK = 16;	/* match tcp packet with Ack flag */
	MATCH_TCP_FLAG_URG = 32;	/* match tcp packet with Urg flag */
	MATCH_TCP_FLAG_ECE = 64;	/* match tcp packet with Ece flag */
	MATCH_TCP_FLAG_CWR = 128;	/* match tcp packet with Cwr flag */
}

/* l2 valid headers */
enum DocaFlowL2ValidHeader {
	L2_VALID_HEADER_DEFAULT = 0;
	L2_VALID_HEADER_VLAN_0 = 1;	/* first vlan */
	L2_VALID_HEADER_VLAN_1 = 2;	/* second vlan */
}

/**
* Doca flow packet format
*/
message DocaFlowHeaderFormat {
	DocaFlowHeaderEth eth = 1;			/* ether head */
	uint32 l2_valid_headers = 2;			/* indicate which headers are valid */
	repeated DocaFlowHeaderEthVlan	eth_vlan = 3;	/* vlan header array */
	uint32 l3_type = 4;				/* layer 3 protocol type */
	oneof protocol_ip {
		DocaFlowHeaderIP4 ip4 = 5;		/* ipv4 header */
		DocaFlowHeaderIP6 ip6 = 6;		/* ipv6 header */
	}
	DocaFlowL4TypeExt l4_type_ext = 7;		/* l4 layer extend type */
	oneof protocol_l4 {
		DocaFlowHeaderIcmp icmp = 8;			/* icmp header */
		DocaFlowHeaderUdp udp = 9;			/* udp header */
		DocaFlowHeaderTcp tcp = 10;			/* tcp header */
	}
}

/*
* DOCA Flow matcher information for pipe/entry building/adding
*
* note: Some of the fields should be used as Big Endian 16 bits.
*/
message DocaFlowMatch {
	uint32 flags = 1;                  	/* match flags */
	DocaFlowMeta meta  = 2;	   		/* match items which are no value */
	DocaFlowHeaderFormat outer = 3;		/* outer layer header format */
	DocaFlowTun tun = 4;			/* tunnel info */
	DocaFlowHeaderFormat inner = 5;    	/* inner layer header format */
}

/* DOCA Flow encap data information */
message DocaFlowEncapAction {
	DocaFlowHeaderFormat outer = 1;	/* modify packet outer headers */
	DocaFlowTun tun = 2;		/* tunnel info */
}

/* Doca flow push action type */
enum DocaFlowPushActionType {
	PUSH_ACTION_VLAN = 0;
}

/* Doca flow push data information */
message DocaFlowPushAction {
	DocaFlowPushActionType type = 1;	/* header type to push */
	DocaFlowHeaderEthVlan vlan = 2;
};


/* DOCA Flow actions information */
message DocaFlowActions {
	uint32 action_idx = 1;		/* index according to place provided on creation */
	uint32 flags = 2;		/* actions flags */
	bool decap = 3;			/* when true, will do decap */
	bool pop = 4;			/* when true, will do decap */
	DocaFlowMeta meta = 5;		/* modify meta data */
	DocaFlowHeaderFormat outer = 6;	/* modify packet outer headers */
	DocaFlowTun tun = 7;		/* modify tunnel headers */
	bool encap_exist = 8;		/* when true, will do encap */
	DocaFlowEncapAction encap = 9;	/* encap data information */
	bool push_exist = 10;		/* when true, push header */
	DocaFlowPushAction push = 11;	/* push header data information */
}

 /* Target type */
enum DocaFlowTargetType {
	TARGET_KERNEL = 0;		/* target kernel */
};

/* Forwarding action type */
enum DocaFlowFwdType {
	FWD_NONE = 0;			/* No forward action */
	FWD_RSS = 1;			/* Forwards packets to rss */
	FWD_PORT = 2;			/* Forwards packets to a port */
	FWD_PIPE = 3;			/* Forwards packets to another pipe */
	FWD_DROP = 4;			/* Drops the packets */
	FWD_TARGET = 5;			/* Forwards packet to target */
	FWD_ORDERED_LIST_PIPE = 6;	/* Forwards packet to a specific entry in an ordered list pipe */
}

/* rss offload types */
enum DocaRSSType {
	DEFAULT = 0;
	RSS_IPv4 = 1;		/* rss by ip header (1 = (1 << 0)) */
	RSS_IPV6 = 2;		/* rss by ipv6 header (4 = (1 << 1)) */
	RSS_UDP = 4;		/* rss by udp header (4 = (1 << 2)) */
	RSS_TCP = 8;            /* rss by tcp header (8 = (1 << 3)) */
}

/* Forwarding configuration message */
message DocaFlowFwd {
	DocaFlowFwdType type = 1;		/* indicate the forwarding type */

	/* The following fields are for rss configuration information */
	uint32 rss_outer_flags = 2;		/* rss offload outer types */
	repeated uint32 rss_queues = 3;		/* rss queues array */
	uint32 num_of_queues = 4;		/* number of queues */
	uint32 shared_rss_id = 5;		/* shared rss id, only for pipe's fwd is NULL */

	/* The following field is for port configuration information */
	uint64 port_id = 6;			/* destination port id */

	/* The following field is for next pipe configuration information */
	uint64 next_pipe_id = 7;		/* next pipe information as a message */

	/* The following field is for ordered list pipe configuration information */
	uint32 idx = 8;				/* index of the ordered list pipe entry */
	uint64 ordered_list_pipe = 9;		/* ordered list pipe to select an entry from */
	uint32 rss_inner_flags = 10;		/* rss offload inner types */

	/* The following field is for target configuration information */
	DocaFlowTargetType target_type = 11;	/* target type */
}

/*
* DOCA Flow rss resource configuration
*/
message DocaFlowResourceRSSCfg {
	uint32 outer_flags = 1;
	repeated uint32 queues_array = 2;
	uint32 nr_queues = 3;
	uint32 inner_flags = 4;
}

/* DOCA Flow meter color */
enum DocaFlowMeterColor {
       METER_COLOR_GREEN = 0;
       METER_COLOR_YELLOW = 1;
       METER_COLOR_RED = 2;
}

/* DOCA Flow meter algorithm */
enum DocaFlowMeterAlgorithmType {
       METER_ALGORITHM_TYPE_RFC2697 = 0;
       METER_ALGORITHM_TYPE_RFC2698 = 1;
       METER_ALGORITHM_TYPE_RFC4115 = 2;
}

/* DOCA Flow meter limit type */
enum DocaFlowMeterLimitType {
       METER_LIMIT_TYPE_BYTES = 0;
       METER_LIMIT_TYPE_PACKETS = 1;
}

/* DOCA Flow meter algorithms */
message DocaFlowMeterRfc2697 {
	uint64 ebs = 1;
}

message DocaFlowMeterRfc2698 {
	uint64 pir = 1;
	uint64 pbs = 2;
}

message DocaFlowMeterRfc4115 {
	uint64 eir = 1;
	uint64 ebs = 2;
}

/* DOCA Flow meter color mode */
enum DocaFlowMeterColorMode {
       METER_COLOR_MODE_BLIND = 0;
       METER_COLOR_MODE_AWARE = 1;
}

/*
* DOCA Flow meter resource configuration
*/
message DocaFlowResourceMeterCfg {
	DocaFlowMeterLimitType limit_type = 1;
	DocaFlowMeterColorMode color_mode = 2;
	DocaFlowMeterAlgorithmType alg = 3;
	uint64 cir = 4;
	uint64 cbs = 5;
	oneof resource_meter_rfc {
		DocaFlowMeterRfc2697 rfc2697 = 6;
		DocaFlowMeterRfc2698 rfc2698 = 7;
		DocaFlowMeterRfc4115 rfc4115 = 8;
	}
}

/**
 * DOCA flow mirror target
 */
message DocaFlowMirrorTarget {
	bool encap_exist = 1;		/* Encap mirrored packets */
	DocaFlowEncapAction encap = 2;	/* Encap data */
	DocaFlowFwd fwd = 3;
}

/**
 * DOCA flow mirror resource configuration
 */
message DocaFlowResourceMirrorCfg {
	int32 nr_targets = 1;				/* Mirror target number */
	repeated DocaFlowMirrorTarget target = 2;	/* Mirror target array */
	DocaFlowFwd fwd = 3;				/* Original packet dst, can be filled optional */
}

/*
* DOCA Flow shared resource configuration
*/
message SharedResourceCfg {
	oneof shared_resource_cfg {
		DocaFlowResourceMeterCfg meter_cfg = 1;
		DocaFlowResourceRSSCfg rss_cfg = 2;
		DocaFlowResourceMirrorCfg mirror_cfg = 3;
	}
}

/* DOCA monitor action flags */
enum DocaFlowMonitorActionFlags {
	MONITOR_NONE = 0; 	/* No monitor action be set */
	MONITOR_METER = 2;	/* set monitor with meter action */
	MONITOR_COUNT = 4;	/* set monitor with counter action */
	MONITOR_AGING = 8; 	/* set monitor with aging action */
	MONITOR_MIRROR = 16;	/* set monitor with mirror action */
}

/* DOCA monitor action configuration message */
message DocaFlowMonitor {
	uint32 flags = 1;                  /* indicate which actions will be included */

	/* meter action configuration */
	DocaFlowMeterLimitType limit_type = 2;		/* rate limit type (per bytes/packets) */
	uint64 cir = 3;                    		/* Committed Information Rate (bytes/second) */
	uint64 cbs = 4;                    		/* Committed Burst Size (bytes) */

	/* shared monitor fields */
	uint32 shared_meter_id = 5;			/* shared meter id */
	DocaFlowMeterColor meter_init_color = 6;	/* shared meter initial color */
	uint32 shared_counter_id = 7;			/* shared counter id */
	uint32 shared_mirror_id = 8;			/* shared mirror id */

	/* meter action configuration */
	uint32 aging = 9;                 		/* aging time in seconds */
}

/* action type enumeration */
enum DocaFlowActionType {
	ACTION_AUTO = 0;	/* Derived from pipe actions */
	ACTION_ADD = 1;		/* Add field value */
	ACTION_COPY = 2; 	/* Copy field to another field */
	ACTION_MAX = 3;		/* End of action type list */
}

/* Extended modification action */
message DocaFlowActionDescField {
	string field_string = 1;	/* Field address of pipe match to decide field type and byte offset */
	uint32 bit_offset = 2;	 	/* Target bit in field from the address */
}

message DocaFlowActionCopy {
	DocaFlowActionDescField src = 1;	/* Source info to copy from */
	DocaFlowActionDescField dst = 2;	/* Source info to copy from */
	uint32 width = 3;			/* Bit width to copy */
}

message DocaFlowActionAdd {
	DocaFlowActionDescField dst = 1;	/* destination info. */
	uint32 width = 2;			/* bit width to add */
}

/* DOCA action descritption.*/
message DocaFlowActionDesc {
	DocaFlowActionType type = 1; /* type */
	/* One of the following fields should be filled base on the action type */
	oneof action_types {
		DocaFlowActionCopy copy = 2;
		DocaFlowActionAdd add = 3;
	}
}

/* DOCA action descriptions */
message DocaFlowActionDescs {
	uint32 nb_action_desc = 1;			/* number of action desc */
	repeated DocaFlowActionDesc desc_array = 2;	/* action description array */
}

/* Type of an ordered list element */
enum DocaFlowOrderedListElementType {
	ORDERED_LIST_ELEMENT_ACTIONS = 0;
	ORDERED_LIST_ELEMENT_ACTION_DESCS = 1;
	ORDERED_LIST_ELEMENT_MONITOR = 2;
}

/* Ordered list Element */
message DocaFlowOrderedListElement {
	DocaFlowActions actions = 1;
	DocaFlowActionDescs action_descs = 2;
	DocaFlowMonitor monitor = 3;
}

/* DOCA Ordered list configuration */
message DocaFlowOrderedList {
	/**
	* List index among the lists of the pipe.
	* At pipe creation, it must match the list position in the array of lists.
	* At entry insertion, it determines which list to use.
	*/
	uint32 idx = 1;
	uint32 size = 2;					/* Number of elements in the list. */
	repeated DocaFlowOrderedListElement elements = 3;	/* An array of DOCA flow structure pointers, depending on types */
	repeated DocaFlowOrderedListElementType types = 4;	/* Types of DOCA Flow structures each of the elements is pointing to */
}

/* DOCA pipe attributes */
message DocaFlowPipeAttr {
	string name = 1;                   	/* name for the pipeline */
	DocaFlowPipeType type = 2;	   	/* type of pipe */
	DocaFlowPipeDomain domain = 3;		/* pipe steering domain */
	bool is_root = 4;                  	/* indicates if the pipe is a root pipe */
	uint32 nb_flows = 5;	           	/* maximum number of flow rules */
	uint32 nb_actions = 6;			/* maximum number of doca flow action array, default is 1 if not set */
	uint32 nb_ordered_lists = 7;		/* number of ordered lists in the array, default 0, mutually exclusive with nb_actions */
}

/* Pipeline configuration message */
message DocaFlowPipeCfg {
	DocaFlowPipeAttr attr = 1;				/* attributes of pipe */
	uint64 port_id = 2;                			/* port for the pipeline */
	DocaFlowMatch match = 3;           			/* matcher for the pipeline */
	DocaFlowMatch match_mask = 4;      			/* match mask for the pipeline */
	repeated DocaFlowActions actions = 5;       		/* actions for the pipeline */
	repeated DocaFlowActions actions_masks = 6;		/* actions mask for the pipeline */
	repeated DocaFlowActionDescs action_descs = 7;		/* action descriptions */
	DocaFlowMonitor monitor = 8;       			/* monitor for the pipeline */
	repeated DocaFlowOrderedList ordered_lists = 9;		/* array of ordered list types */
}

/* DOCA Flow query message */
message DocaFlowQuery {
	uint64 total_bytes = 1;        /* Total bytes that hit this flow */
	uint64 total_pkts = 2;         /* Total packets that hit this flow */
}

/* ################################################## */
		/* Response messsages */
/* ################################################## */

message DocaFlowAgingHandleRes {
	int32 res = 1;
	repeated uint64 entries = 2;
}

message EntriesProcessRes {
	repeated uint64  entries_ids = 1;
	repeated DocaFlowEntryStatus status = 2;
	repeated uint32 pipe_queue = 3;
}

message DocaFlowMplsLabelDecodeResponse {
	uint32 label = 1;		/* label value */
	uint32 traffic_class = 2;	/* traffic class */
	uint32 ttl = 3;			/* time to live */
	bool bottom_of_stack = 4;	/* whether this MPLS is bottom of stack */
}

/* General DOCA Flow response message */
message DocaFlowResponse{
	bool success = 1;	/* True in case of success */
	uint32 result = 2;	/* DOCA error type */
	/* in case of success, one or more of the following may be used */
	uint64 port_id = 3;
	uint64 pipe_id = 4;
	uint64 entry_id = 5;
	string pipe_dump = 6;
	string port_pipes_dump = 7;
	DocaFlowQuery query_stats = 8;
	bytes priv_data = 9;
	DocaFlowAgingHandleRes handle_aging_res = 10;
	EntriesProcessRes entries_process_res = 11;
	DocaFlowEntryStatus status = 12;
	repeated DocaFlowQuery query_results = 13;
	uint64 switch_port_id = 14;
	DocaFlowHeaderMpls mpls = 15;
	DocaFlowMplsLabelDecodeResponse mpls_label_decode_response = 16;

}

/* ################################################## */
		/* Request messsages */
/* ################################################## */

/* Here for future compatibility */
message DocaFlowEmptyRequest {
}

message DocaFlowSharedResourceCfgRequest {
	DocaFlowSharedResourceType type = 1;	/* Shared resource type */
	uint32 id = 2; 				/* Shared resource id */
	SharedResourceCfg cfg = 3;	/* Shared resource configuration */
}

message DocaFlowSharedResourcesBindRequest {
	DocaFlowSharedResourceType type = 1;		/* Shared resource type */
	repeated uint32 resource_arr = 2;		/* Repeated shared resource IDs */
	/* id of allowed bindable object, use 0 to bind globally */
	oneof bindable_obj_id {
		uint64 port_id = 3; /* Used if the bindable object is port */
		uint64 pipe_id = 4; /* Used if the bindable object is pipe */
	}
}

message DocaFlowSharedResourcesQueryRequest {
	DocaFlowSharedResourceType type = 1;	/* Shared object type */
	repeated uint32 res_array = 2;		/*  Array of shared objects IDs to query */
}

message DocaFlowPipeCreateRequest {
	DocaFlowPipeCfg cfg = 1;           /* the pipe configurations */
	DocaFlowFwd fwd = 2;               /* the pipeâs FORWARDING component */
	DocaFlowFwd fwd_miss = 3;          /* The FORWARDING miss component */
}

message DocaFlowPipeAddEntryRequest{
	uint32 pipe_queue = 1;             	/* the pipe queue */
	uint64 pipe_id = 2;                	/* the pipe id to add the entry to */
	DocaFlowMatch match = 3;           	/* matcher for the entry */
	DocaFlowActions actions = 4;       	/* actions for the entry */
	DocaFlowMonitor monitor = 5;       	/* monitor for the entry */
	DocaFlowFwd fwd = 6;               	/* The entryâs FORWARDING component */
	uint32 flags = 7;		   	/* wether the flow entry will be pushed to HW immediately or not */
}

message DocaFlowPipeUpdateEntryRequest{
	uint32 pipe_queue = 1;             	/* the pipe queue */
	uint64 pipe_id = 2;                	/* the pipe id of the entry to update */
	DocaFlowActions actions = 3;       	/* actions for the entry */
	DocaFlowMonitor monitor = 4;       	/* monitor for the entry */
	DocaFlowFwd fwd = 5;               	/* The entryâs FORWARDING component */
	uint32 flags = 6;		   	/* wether the flow entry will be pushed to HW immediately or not */
	uint64 entry_id = 7;			/* the entry id to update */
}

message DocaFlowPipeControlAddEntryRequest{
	uint32 priority = 1;			/* the priority of the updated entry to the filter pipe */
	uint32 pipe_queue = 2;			/* the pipe queue */
	uint64 pipe_id = 3;			/* the pipe id to add the entry to */
	DocaFlowMatch match = 4;		/* matcher for the entry */
	DocaFlowMatch match_mask = 5;		/* matcher mask for the entry */
	DocaFlowActions actions = 6;		/* actions for the entry */
	DocaFlowActions actions_mask = 7;	/* actions mask for the entry */
	DocaFlowFwd fwd = 8;			/* The entryâs FORWARDING component */
}

message DocaFlowPipeLpmAddEntryRequest{
       uint32 pipe_queue = 1;                  /* the pipe queue */
       uint64 pipe_id = 2;                     /* the pipe id to add the entry to */
       DocaFlowMatch match = 3;                /* matcher for the entry */
       DocaFlowMatch match_mask = 4;           /* matcher mask for the entry */
       DocaFlowActions actions = 5;            /* actions for the entry */
       DocaFlowMonitor monitor = 6;            /* monitor for the entry */
       DocaFlowFwd fwd = 7;                    /* The entryâs FORWARDING component */
       uint32 flag = 8;
}
message DocaFlowPipeOrderedListAddEntryRequest{
	uint32 pipe_queue = 1;				/* the pipe queue */
	uint64 pipe_id = 2;				/* the pipe id to add the entry to */
	uint32 idx = 3;					/* unique entry index. It is the user's responsibility to ensure uniqueness */
	DocaFlowOrderedList ordered_list = 4;		/* ordered list, as described in the API documentation */
	DocaFlowFwd fwd = 5;				/* The entryâs FORWARDING component */
	uint32 flags = 6;				/* wether the flow entry will be pushed to HW immediately or not */
}

message DocaFlowPipeHashAddEntryRequest {
	uint32 pipe_queue = 1;		/* the pipe queue identifier */
	uint64 pipe_id = 2;		/* the pipe id to add the entry to */
	uint32 entry_idx = 3;		/* index in pipe for this entry */
	DocaFlowActions actions = 4;	/* actions for the created entry */
	DocaFlowMonitor monitor = 5;	/* monitor for the created entry */
	DocaFlowFwd fwd = 6;		/* forwarding component for the created entry */
	FlagsType flags = 7;		/* whther the entry will be pushed to HW immediately or not */
}

message DocaFlowPipeRmEntryRequest{
	uint32 pipe_queue = 1;             /* the pipe queue of the entry to remove */
	uint64 entry_id = 2;               /* the entry id to be removed */
}

message DocaFlowPipeDestroyRequest{
	uint64 pipe_id = 1;                /* the pipe id to destroy */
}

message DocaFlowQueryEntryRequest{
	uint64 entry_id = 1;               /* the entry id */
}

message DocaFlowAgingHandleRequest{
	uint64 port_id = 1;                /* the port id handle aging to */
	uint32 queue = 2;                  /* the queue identifier */
	uint64 quota = 3;                  /* the max time quota in micro seconds for this function to handle aging */
	uint64 max_entries = 4;            /* the max entries for this function to handle aging, 0: no limit. */
}

message DocaFlowEntriesProcessRequest{
	uint64 port_id = 1;	/* the port identifier of the processed entries */
	uint32 pipe_queue = 2;	/* the pipe queue of the processed entries */
	/* max time in micro seconds for this function to process entries. 0 means processing one entry */
	uint64 timeout = 3;
	uint32 max_processed_entries = 4; /* the required number of entries to process */
}

message DocaFlowPipeEntryGetStatusRequest {
	uint64 entry_id = 1;	/* the entry identifier of the requested entry's status */
}

message DocaFlowPortPairRequest {
	uint64 port_id = 1;		/* port identefier of doca flow port */
	uint64 pair_port_id = 2;	/* port identefier to the pair port */
}

message DocaFlowMplsLabelEncodeRequest {
	uint32 label = 1;		/* label value - 20 bits */
	uint32 traffic_class = 2;	/* traffic class - 3 bits */
	uint32 ttl = 3;			/* time to live - 8 bits */
	bool bottom_of_stack = 4;	/* whether this MPLS is bottom of stack */
}

message DocaFlowMplsLabelDecodeRequest {
	DocaFlowHeaderMpls mpls = 1;	/* MPLS structure to decode */
}

message DocaFlowGetTargetRequest {
	DocaFlowTargetType type = 1;	/* target type */
}
