/*
 * Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES, ALL RIGHTS RESERVED.
 *
 * This software product is a proprietary product of NVIDIA CORPORATION &
 * AFFILIATES (the "Company") and all right, title, and interest in and to the
 * software product, including all associated intellectual property rights, are
 * and shall remain exclusively with the Company.
 *
 * This software product is governed by the End User License Agreement
 * provided with the software product.
 *
 */

/**
 * @defgroup DPA_HOST DPA Host
 * DOCA DPA Host library. For more details please refer to the user guide on DOCA devzone.
 *
 * @ingroup DPA
 *
 * @{
 */
#ifndef DOCA_DPA_H_
#define DOCA_DPA_H_

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <doca_compat.h>
#include <doca_error.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Forward declarations
 */
struct doca_devinfo;
struct doca_dev;
struct doca_dpa;
/** DPA context type definition */
typedef struct doca_dpa *doca_dpa_t;
struct doca_sync_event;
/** DPA pointer type definition */
typedef uint64_t doca_dpa_dev_uintptr_t;
struct doca_dpa_mem;
/** DPA memory type definition */
typedef struct doca_dpa_mem *doca_dpa_mem_t;
/** DPA memory handle type definition */
typedef uint64_t doca_dpa_dev_mem_t;
struct doca_dpa_worker;
/** DPA worker type definition */
typedef struct doca_dpa_worker *doca_dpa_worker_t;
struct doca_dpa_ep;
/** DPA endpoint type definition */
typedef struct doca_dpa_ep *doca_dpa_ep_t;
/** DPA endpoint handle type definition */
typedef uint64_t doca_dpa_dev_ep_t;
struct doca_dpa_ep_addr;
/** DPA endpoint address type definition */
typedef struct doca_dpa_ep_addr *doca_dpa_ep_addr_t;

/**
 * \brief Opaque representation of a DPA Application
 *
 * This is an opaque structure that encapsulates a DPA application.
 * Typically, the DOCA DPA Host application will obtain the value
 * of this structure by linking in the appropriate stub library that is generated by DPACC
 */
struct doca_dpa_app;
/** DPA application type definition */
typedef struct doca_dpa_app *doca_dpa_app_t;

/**
 * \brief Generic function pointer type
 *
 * Kernel launches are made using a host function pointer that represents the device function.
 * The host function stub is provided by the associated DPA compiler.
 * The C language does not define conversion of a function pointer to an object pointer (such as void*).
 * Programmers can use this generic function pointer type to typecast to
 * and adhere to strict ISO C language requirements
 */
typedef void (doca_dpa_func_t)(void);

/**
 * \brief Get DPA application name
 *
 * The name of a DPA application is assigned using DPACC during the build phase.
 * Once an application has been formed, its name is embedded within it.
 * This function allows DOCA DPAâ€™s host application to retrieve the name that was previously assigned.
 *
 * The app_name buffer is allocated by the caller along with setting app_name_len indicating the length that was
 * allocated. Upon return the app_name_len field is set to the actual length of the app_name
 *
 * @param app [in] - DPA application generated by DPACC
 * @param app_name [out] - Application name
 * @param app_name_len [in/out] - app_name length. Output is actual number of bytes written
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input, or the buffer received is of insufficient length
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_app_name_get(doca_dpa_app_t app, char *app_name, int *app_name_len);

/**
 * @brief Get whether the DOCA device supports DPA
 *
 * @param devinfo [in] - The device to query
 *
 * @return
 * DOCA_SUCCESS - in case of the DOCA device quered has DPA support
 * Error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NOT_SUPPORTED - the device quered does not support DPA
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_devinfo_get_is_dpa_supported(const struct doca_devinfo *devinfo);

/**
 * @brief Get maximum number of DPA threads to run a single kernel launch operation
 *
 * @param dpa [in] - DPA context
 * @param value [out] - Number of maximum threads to run a kernel
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * Error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid NULL input
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_get_max_threads_per_kernel(doca_dpa_t dpa, unsigned int *value);

/**
 * @brief Get maximum allowable time in seconds that a kernel may remain scheduled on the DPA.
 * A kernel that remains scheduled beyond this limit may be terminated by the runtime and cause fatal behaviour
 *
 * @param dpa [in] - DPA context
 * @param value [out] - maximum allowed time in seconds for a kernel to remain scheduled
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * Error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid NULL input
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_get_kernel_max_run_time(doca_dpa_t dpa, unsigned long long *value);

/**
 * @brief Return the last error generated on the DPA.
 * Check if an error occurred on the device side runtime. This call does not reset the error state.
 * If an error occured, the DPA context enters a fatal state and must be destroyed by the user
 *
 * @param dpa [in] - DPA context
 *
 * @return
 * DOCA_SUCCESS - in case of no error state
 * Error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid NULL input
 * - DOCA_ERROR_BAD_STATE - received error on device side
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_peek_at_last_error(const doca_dpa_t dpa);

/**
 * \brief Create a DOCA DPA Context
 *
 * This function creates a DOCA DPA context given a DOCA device.
 * The context represents a program on the DPA that is referenced
 * by the host process that called the context creation API
 *
 * @param dev [in] - DOCA device
 * @param app [in] - DPA application generated by DPACC
 * @param dpa [out] - Created context
 * @param flags [in] - Reserved
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_NOT_SUPPORTED - the device does not support DPA
 * - DOCA_ERROR_NO_MEMORY - in case of failure in internal memory allocation
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_create(struct doca_dev *dev, doca_dpa_app_t app, doca_dpa_t *dpa, unsigned int flags);

/**
 * \brief Destroy a DOCA DPA context
 *
 * This function destroys DPA context created by doca_dpa_create()
 *
 * @param dpa [in] - Previously created DPA context
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_destroy(doca_dpa_t dpa);

/**
 * \brief Submit a kernel to DPA that sets completion event
 *
 * This function submits a kernel for launch on the specified `dpa` context.
 * The kernel starts execution when its wait event value is greater than
 * or equal to specified threshold. The completion event is set to value
 * specified in `comp_count` when the kernel finishes execution.
 *
 * The function to be launched `func` is a host function
 * pointer corresponding to the DPA device function.
 * For example, if the device function is declared as: `__dpa_global__ hello(int arg1)`,
 * then the user is expected to declare the function in the Host application
 * as `extern doca_dpa_func_t hello;`. After the application is linked and loaded
 * using the compiler, a function pointer `hello` can be used in as the `func` argument.
 * The arguments to the function `hello` can be passed inline in the call as var args.
 * For example, to call `hello` on the device using `4` threads with argument `5`,
 * the invocation looks like: `doca_dpa_kernel_launch_update_set(..., 4, hello, 5);`
 *
 * @param dpa [in] - Previously created DPA context
 * @param wait_event [in] - Event to wait on before executing the kernel (optional)
 * @param wait_threshold [in] - Wait event count threshold to wait for before executing. Valid values [0-254]
 * @param comp_event [in] - Event to signal after kernel execution is complete (optional)
 * @param comp_count [in] - Completion count to set for completion event when func is complete
 * @param nthreads [in] - Number of threads to use. This number must be equal or lower than
 * 				the maximum allowed (see doca_dpa_get_max_threads_per_kernel)
 * @param func [in] - Host function pointer representing DPA kernel
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_kernel_launch_update_set(struct doca_dpa *dpa,
				    struct doca_sync_event *wait_event,
				    uint64_t wait_threshold,
				    struct doca_sync_event *comp_event,
				    uint64_t comp_count,
				    unsigned int nthreads,
				    doca_dpa_func_t *func,
				    ... /* args */);

/**
 * \brief Submit a kernel to DPA
 *
 * This function submits a kernel for launch on the specified `dpa` context.
 * The kernel starts execution when its wait event value is greater than
 * or equal to specified threshold. The value specified in `comp_count`
 * is added to the `comp_event` when the kernel finishes execution.
 *
 * @param dpa [in] - Previously created DPA context
 * @param wait_event [in] - Event to wait on before executing the kernel (optional)
 * @param wait_threshold [in] - Wait event count threshold to wait for before executing. Valid values [0-254]
 * @param comp_event [in] - Event to signal after kernel execution is complete (optional)
 * @param comp_count [in] - Completion count to add for completion event when func is complete
 * @param nthreads [in] - Number of threads to use. This number must be equal or lower than
 * 				the maximum allowed (see doca_dpa_get_max_threads_per_kernel)
 * @param func [in] - Host function pointer representing DPA kernel
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_kernel_launch_update_add(struct doca_dpa *dpa,
				    struct doca_sync_event *wait_event,
				    uint64_t wait_threshold,
				    struct doca_sync_event *comp_event,
				    uint64_t comp_count,
				    unsigned int nthreads,
				    doca_dpa_func_t *func,
				    ... /* args */);


/**
 * \brief Allocate DPA heap memory
 *
 * This function allocates memory of `size` bytes on the DPA process heap.
 * The memory is aligned for any language supported data type.
 * The memory is not zeroed on allocation. The allocated memory is returned in `dev_ptr` when successful.
 * When memory allocation fails, `dev_ptr` is set to 0x0 (NULL)
 *
 * @param dpa [in] - DPA context
 * @param size [in] - Requested size of allocation
 * @param dev_ptr [out] - Pointer to the allocated memory on the DPA device
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_mem_alloc(doca_dpa_t dpa, size_t size, doca_dpa_dev_uintptr_t *dev_ptr);

/**
 * \brief Free the previously allocated DPA memory
 *
 * This function frees the allocated memory allocated on the DPA heap. Users are expected to
 * ensure that kernels on the DPA are no longer accessing the memory
 * using established synchronization mechanisms (see events)
 *
 * @param dpa [in] - DPA context
 * @param dev_ptr [in] - Pointer to the memory that was previously allocated on the DPA device
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_mem_free(doca_dpa_t dpa, doca_dpa_dev_uintptr_t dev_ptr);

/**
 * \brief Copy from host memory to DPA Heap
 *
 * This function copies data from Host memory to the DPA heap. This is a blocking call.
 * When the call returns, the memory on the DPA is set to the values supplied in the Host buffer
 *
 * @param dpa [in] - DPA context
 * @param dev_ptr [in] - DPA device heap pointer
 * @param src_ptr [in] - Host source buffer
 * @param size [in] - Size of data to copy
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_h2d_memcpy(doca_dpa_t dpa, doca_dpa_dev_uintptr_t dev_ptr, void *src_ptr, size_t size);

/**
 * \brief Set DPA Heap memory to a value
 *
 * This function sets DPA heap memory to a supplied value. This is a blocking call.
 * When the call returns, the memory on the DPA is set to the value supplied
 *
 * @param dpa [in] - DPA context
 * @param dev_ptr [in] - DPA device heap pointer
 * @param value [in] - Value to set
 * @param size [in] - Size of device buffer
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_memset(doca_dpa_t dpa, doca_dpa_dev_uintptr_t dev_ptr, int value, size_t size);

/**
 * \brief Register Host memory to be used with DOCA DPA
 *
 * This function registers host memory with DOCA DPA. The resulting memory can be used on the DPA to initiate
 * operations such as memory copies and for network operations by DPA endpoints
 *
 * @param dpa [in] - DPA context
 * @param addr [in] - Pointer in Host address space for buffer
 * @param length [in] - Length of memory region
 * @param access [in] - Memory access permissions (see doca_access_flags)
 * @param mem [out] - Memory structure allocated
 * @param flags [in] - Flags (reserved)
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_NO_MEMORY - in case of failure in internal memory allocation
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_mem_host_register(doca_dpa_t dpa,
					void *addr,
					size_t length,
					unsigned int access,
					doca_dpa_mem_t *mem,
					unsigned int flags);

/**
 * \brief Unregister memory
 *
 * This function unregisters memory that was previously registered
 *
 * @param mem [in] - Previously registered memory
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_mem_unregister(doca_dpa_mem_t mem);

/**
 * \brief Export a handle for the memory that can be used on DPA
 *
 * This function returns a handle for the memory to be used in the DPA kernels
 * For example:
 *	doca_dpa_mem_host_register(..., &mem, 0) - register host memory
 *	doca_dpa_mem_dev_export(mem, &mem_handle) - export a handle to the registered memory
 *	doca_dpa_kernel_launch_update_set(..., func, mem_handle) - pass the handle as an argument to the kernel
 *
 * @param mem [in] - Memory to obtain a handle for
 * @param handle [out] - Handle that can be passed to a kernel
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_mem_dev_export(doca_dpa_mem_t mem, doca_dpa_dev_mem_t *handle);

/**
 * \brief Get remote memory key of registered memory
 *
 * This function returns the remote memory key for a memory region that
 * was registered. To obtain an rkey, the memory region must have been provided remote access capabilities, otherwise,
 * an error is returned and rkey is set to zero
 *
 * @param mem [in] - Memory to obtain the remote key for
 * @param rkey [out] - Remote key
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NOT_PERMITTED - memory region was not provided remote access capabilities
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_mem_rkey_get(doca_dpa_mem_t mem, uint32_t *rkey);

/**
 * \brief Create worker
 *
 * This function creates a worker on a provided DPA context.
 * A worker is required in order to create any endpoints to communicate out of this DPA context.
 *
 * @param dpa [in] - DPA context
 * @param worker [out] - Worker that was created
 * @param flags [in] - Flags (reserved)
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NO_MEMORY - in case of failure in internal memory allocation
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_worker_create(doca_dpa_t dpa, doca_dpa_worker_t *worker, unsigned int flags);

/**
 * \brief Destroy worker
 *
 * This function destroys a worker that was previously created.
 * The behavior of communication operations is undefined if the worker is destroyed before the communications issued
 * are complete
 *
 * @param worker [in] - Previously created DPA worker
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_IN_USE - in case of destroying a worker with an associated resource, such as endpoint
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_worker_destroy(doca_dpa_worker_t worker);

/**
 * \brief Create an endpoint
 *
 * This function creates a network endpoint for the given worker.
 * The endpoint capabilities control which operations are allowed on the endpoint.
 * The endpoint resources on the DPA are not thread safe, and accessing the endpoint on the DPA with multiple threads
 * may result in errors and the state of the communication operations are undefined
 *
 * @param worker [in] - Worker to create the endpoint for
 * @param access [in] - Access for the endpoint (see doca_access_flags)
 * @param ep [out] - Created endpoint
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_NO_MEMORY - in case of failure in internal memory allocation
 * - DOCA_ERROR_AGAIN - in case of temporary unavailable resources, try again
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_ep_create(doca_dpa_worker_t worker, unsigned int access, doca_dpa_ep_t *ep);

/**
 * \brief Destroy an endpoint
 *
 * This function destroys an endpoint that was previously created. The application should ensure communication
 * operations submitted on the endpoint are complete before destroying the endpoint.
 * Destroying an endpoint on which communication operations are still pending may result in errors and the state of the
 * communication operations are undefined
 *
 * @param ep [in] - Previously created DPA endpoint
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_ep_destroy(doca_dpa_ep_t ep);

/**
 * \brief Export a handle for the endpoint that can be used on DPA
 *
 * This function returns a handle for the endpoint to be used in the DPA kernels to initiate network operations
 *
 * For example:
 *	doca_dpa_ep_create(worker, access, &ep) - create endpoint
 *	doca_dpa_ep_dev_export(ep, &ep_handle) - export a handle to the endpoint
 *	doca_dpa_kernel_launch_update_set(..., func, ep_handle) - pass the handle as an argument to the kernel
 *
 * Using the endpoint handle to access the endpoint on the DPA with multiple threads may result in errors and the state
 * of the communication operations are undefined
 *
 * @param ep [in] - Endpoint to obtain a handle for
 * @param handle [out] - Handle that can be passed to a kernel
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_ep_dev_export(doca_dpa_ep_t ep, doca_dpa_dev_ep_t *handle);

/**
 * \brief Get an endpoints's address
 *
 * This function retrieves an endpointâ€™s address to be used for connecting remote EPs to it.
 * The memory that holds the address is allocated by the library.
 * Users must call `doca_dpa_ep_addr_free` to free this memory
 *
 * @param ep [in] - Previously created DPA endpoint
 * @param addr [in] - Pointer to the endpoint address
 * @param addr_length [out] - Length of endpoint address
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NO_MEMORY - in case of failure in internal memory allocation
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_ep_addr_get(doca_dpa_ep_t ep, doca_dpa_ep_addr_t *addr, size_t *addr_length);

/**
 * \brief Free the memory holding the endpoint address
 *
 * This function frees the memory allocated by the library to hold the endpoint address.
 * The memory is allocated when the user calls doca_dpa_ep_addr_get()
 *
 * @param addr [in] - Address that was previously Obtained
 *
 * @return
 * DOCA_SUCCESS - in case of success
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_ep_addr_free(doca_dpa_ep_addr_t addr);

/**
 * \brief Connect an endpoint
 *
 * This function connects an endpoint with a remote endpoint using the remote endpointâ€™s address.
 * The remote endpointâ€™s address maybe be obtained by exchanging the addresses out-of-band. The connection call is
 * one-sided. That means, the target application does not need to make a matching connect call.
 *
 * @param ep [in] - Local endpoint that was created previously
 * @param addr [in] - Address of remote endpoint
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_CONNECTION_ABORTED - in case the endpoint is already in a connected state
 */
__DOCA_EXPERIMENTAL
doca_error_t doca_dpa_ep_connect(doca_dpa_ep_t ep, doca_dpa_ep_addr_t addr);

#ifdef __cplusplus
}
#endif

#endif /* DOCA_DPA_H_ */

/** @} */
